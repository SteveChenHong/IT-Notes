1.產生自簽署憑證  
Git內建有openssl工具可以產生  
參考:https://blog.miniasp.com/post/2019/02/25/Creating-Self-signed-Certificate-using-OpenSSL

如文章生成憑證crt檔案(含公鑰)、key檔案(私鑰)
```
openssl req -x509 -new -nodes -sha256 -utf8 -days 3650 -newkey rsa:2048 -keyout server.key -out server.crt -config ssl.conf
```
然後可以再產生一個含公私鑰的憑證檔案，如文章
```
openssl pkcs12 -export -in server.crt -inkey server.key -out server.pfx
```

2.C#服務憑證驗證機制(不確定是否可行)
參考:https://blog.darkthread.net/blog/verify-android-sign-w-dotnet/
```
//取得憑證物件
var serverCert = new X509Certificate2("server.pfx", "pwd");

//利用憑證的私鑰簽署一段文字
var privateKey = serverCert.GetRSAPrivateKey()!;

//取得簽章
var signature = privateKey.SignData(Encoding.UTF8.GetBytes("hi"), HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

//可將簽章變成base64文字作保存，或提供給客戶??這裡預期客戶只需要提供憑證即可驗證，所以應該不用給客戶?
var base64 = Convert.ToBase64String(signature);

//假設會把產生的crt憑證提供給客戶，客戶再將憑證傳到服務(Request.ClientCertificate好像可以取得客戶傳來的憑證資料)
var clientCert = new X509Certificate2("server.crt");

//取得憑證公鑰
var publicKey = clientCert.GetRSAPublicKey()!;

//用憑證的公鑰去驗證簽名檔案是否正確，來驗證客戶的憑證是否對我來說合法????
bool isValidSignature = publicKey.VerifyData(Encoding.UTF8.GetBytes("hi"), Convert.FromBase64String(base64), HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
```
